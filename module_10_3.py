from platform import release
from time import sleep

print("=== Потоки на классах. ====\n")

# Задача "Банковские операции.":
# Необходимо создать класс Bank со следующими свойствами:
#
# Атрибуты объекта:
# balance - баланс банка (int)
# lock - объект класса Lock для блокировки потоков.
#
# Методы объекта:
# Метод deposit:
# 1.Будет совершать 100 транзакций пополнения средств.
# 2.Пополнение - это увеличение баланса на случайное целое число от 50 до 500.
# 3.Если баланс больше или равен 500 и замок lock заблокирован - lock.locked(), то разблокировать его методом release.
# 4.После увеличения баланса должна выводится строка "Пополнение: <случайное число>. Баланс: <текущий баланс>".
# 5.Также после всех операций поставьте ожидание в 0.001 секунды, тем самым имитируя скорость выполнения пополнения.
# Метод take:
# 1.Будет совершать 100 транзакций снятия.
# 2.Снятие - это уменьшение баланса на случайное целое число от 50 до 500.
# 3.В начале должно выводится сообщение "Запрос на <случайное число>".
# 4.Далее производится проверка: если случайное число меньше или равно текущему балансу, то произвести снятие,
# уменьшив balance на соответствующее число и вывести на экран "Снятие: <случайное число>. Баланс: <текущий баланс>".
# 5.Если случайное число оказалось больше баланса, то вывести строку "Запрос отклонён, недостаточно средств" и
# заблокировать поток методом acquire.
# Далее создайте объект класса Bank и создайте 2 потока для его методов deposit и take. Запустите эти потоки.
# После конца работы потоков выведите строку: "Итоговый баланс: <баланс объекта Bank>".
#
# По итогу вы получите скрипт разблокирующий поток до баланса равному 500 и больше или блокирующий, когда происходит
# попытка снятия при недостаточном балансе.
#
# Примечания:
# 1.Для генерации случайного целого числа используйте функцию randint из модуля random.
# 2.Для ожидания используйте функцию sleep из модуля time.
# 3.Особо важно соблюсти верную блокировку: в take замок закрывается, в deposit открывается.
# *******************************************************************************************
# Дополнение:
#  - Для контроля ситуации, когда deposit работу закончил, а take еще нет - вводим атрибут stop_thread
#  - Если Deposit закончил работу - stop_thread переходит в True и take, если не может больше снимать суму с баланса -
#  завершает работу (так как поступлений не предвидится)
#  - При i=0 в методе deposit принудительно вводим acquire, иначе take - делает лишний шаг.
#  - Для аккуратного вывода информации вводим стат метод print_line. Для избежания перехвата состояния семафора
#  экземпляра класса, используем обращение <class>.<method> и отдельный семафор.
# - Для симуляции аварийной ситуации беру для take 200 транзакций вместо 100.
import threading
from random import randint  # импортируем функцию randint
from time import sleep


# === Классы ===
class Bank:

    @staticmethod
    def print_line(x):  # Чтобы каждый принт выводился на отдельной строке.
        cv.acquire()  # Блокируем работу остальных потоков
        threading.Thread(target=print, args=(x,)).start()
        cv.release()  # Разблокируем работу остальных потоков

    def __init__(self, balance: int = 0):
        self.balance = balance
        self.lock = threading.Lock()
        self.stop_thread = False

    def deposit(self):
        for i in range(100):
            if i == 0:  # Устанавливаем очередность запуска - deposit - первый, потом - take
                self.lock.acquire()
            if self.lock.locked():
                Bank.print_line(f'{i + 1}# Deposit - Процесс заблокирован.')  # Для мониторинга состояния.
            rand_value = randint(50, 500)
            Bank.print_line(f'{i + 1}# Запрос на пополнение {rand_value}.')
            self.balance += rand_value  # Пополнение баланса.
            Bank.print_line(f'Пополнение: {rand_value}. Баланс: {self.balance}')
            sleep(0.1)
            if self.lock.locked() and self.balance >= 500:
                Bank.print_line(f'{i + 1}# Процесс разблокирован')  # Для мониторинга состояния.
                self.lock.release()  # Разблокировка потока при балансе >= 500
        Bank.print_line(f'Deposit - Работу закончил.')  # Индикация окончания работы deposit.
        self.stop_thread = True  # Инициируем завершение остальных запущенных потоков.

    def take(self):
        for i in range(200):
            if not self.lock.locked():
                Bank.print_line(f'{i + 1}# Take - Процесс разблокирован.')  # Для мониторинга состояния.
            rand_value = randint(50, 500)
            Bank.print_line(f'{i + 1}# Запрос на снятие {rand_value}.')
            if rand_value < self.balance:  # Если запрос меньше баланса - отнимаем от баланса запрос.
                self.balance -= rand_value  # Уменьшаем баланс.
                Bank.print_line(f'Снятие: {rand_value}. Баланс: {self.balance}')
            else:
                Bank.print_line(f'Запрос отклонён, недостаточно средств.')
                if self.stop_thread:  # Если запущено завершение потоков (deposit завершил работу) - завершаем take.
                    break
                self.lock.acquire()  # Блокировка потока, когда происходит попытка снятия при недостаточном балансе.


# === Прогон ===
bk = Bank()
cv = threading.Condition()  # Отдельный семафор для print_line.
# Т.к. методы принимают self, в потоки нужно передать сам объект класса Bank
th1 = threading.Thread(target=Bank.deposit, args=(bk,))
th2 = threading.Thread(target=Bank.take, args=(bk,))
th1.start()
th2.start()
th1.join()
th2.join()

print(f'Итоговый баланс: {bk.balance}')
# print(threading.enumerate())
print('\n=== Коней обработки. === ')
