print("=== Базовые структуры данныx. ===")
# Применить знания полученные в модуле, решив задачу повышенного уровня сложности
# Задание "Средний балл":
print ("=== Средний бал ===")
# *****************************************************************************************
# Вам необходимо решить задачу из реальной жизни: "школьные учителя устали подсчитывать
# вручную средний балл каждого ученика, поэтому вам предстоит автоматизировать этот процесс":
# На вход даны следующие данные:

# Список: grades = [[5, 3, 3, 5, 4], [2, 2, 2, 3], [4, 5, 5, 2], [4, 4, 3], [5, 5, 5, 4, 5]]
grades = [[5, 3, 3, 5, 4], [2, 2, 2, 3], [4, 5, 5, 2], [4, 4, 3], [5, 5, 5, 4, 5]]
# Множество: students = {'Johnny', 'Bilbo', 'Steve', 'Khendrik', 'Aaron'
students = {"Johny",'Bilbo', 'Steve', 'Khendrik', 'Aaron'}
print (" Список оценок - ",grades)
print (" Множество студентов - {}".format(str(sorted(students)).replace('[','{').replace(']','}')))
#print(grades)
#print(sorted(students))


# Список grades содержит списки оценок для каждого ученика в алфавитном порядке.
# Например: 'Aaron' - [5, 3, 3, 5, 4]

# Множество students содержит неупорядоченную последовательность имён всех учеников в классе.

# Напишите программу, которая составляет словарь, используя grades и students, где ключом будет имя ученика,
# а значением - его средний балл.
# Вывод в консоль:
# {'Aaron': 4.0, 'Bilbo': 2.25, 'Johhny': 4.0, 'Khendrik': 3.6666666666666665, 'Steve': 4.8}
# *********************************************************************************************
# Для формирования списка со средними значениями используем конструкт round(sum(x)/len(x),2) for x in grades.
# Для округления значений среднего до двух после запятой используем функцию round (x,2).
# Чтобы было по красоте - переводим в строку + добавляем справа 0 и обрезаем слева 4 символа
# (так как у нас оценка между 1 - 5).
# Для объединения списка и множества используем функцию zip.
# ******************** Дополнение к условию ***********************
# У коллекции set есть неприятная особенность. При присваивании начальных значений они располагаются в коллекции
# каждый раз - по своему. Поэтому добиться однозначного расположения студентов в множестве в одинаковом порядке
# при перезапуске программы - невозможно. Поэтому, для склейки студентов и оценок считаю, что оценки отражают список
# студентов в алфавитном порядке. Т.е. перед склейкой средней оценки к студентам - список студентов нужно отсортировать
# в алфавитном порядке.

result = dict(zip(sorted(students),[(str(round(sum(x)/len(x),2))+"0")[:4] for x in grades]))
print ("\n Результирующая коллекция - {}".format(result))

# Так как список уже отсортирован, то дополнительная  сортировка уже не нужна. Ниже можно не читать.
# ****************************************************************************************************
# Так как нам словарь на выходе нужно отсортировать по ключу, то используем конструкт
# {k:v for k, v in sorted(result.items(), key=lambda item: item[0])}. Создаем словарь относительно result с сортировкой
# Если используем item[0], то сортируем по ключу, если по item[1] - то по значению.
# print ( " Результирующая коллекция - {}".format({k:v for k, v in sorted(result.items(), key=lambda item: item[0])}))

